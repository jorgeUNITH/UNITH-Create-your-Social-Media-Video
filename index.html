<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Concatenar + Chroma Key (WebCodecs H.264)</title>
  <style>
    :root { color-scheme: light dark; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial; margin: 0; padding: 2rem; }
    .wrap { max-width: 1100px; margin: 0 auto; }
    h1 { font-size: 1.5rem; margin: 0 0 1rem; }
    .card { background: rgba(127,127,127,.08); border: 1px solid rgba(127,127,127,.2); border-radius: 14px; padding: 1rem; }
    .row { display: flex; gap: .75rem; align-items: center; flex-wrap: wrap; }
    label { display:flex; align-items:center; gap:.35rem; }
    input[type="file"], input[type="number"], input[type="range"] { padding: .4rem; border: 1px solid rgba(127,127,127,.35); border-radius: 10px; }
    button { appearance: none; border: 0; padding: .7rem 1rem; border-radius: 12px; font-weight: 600; cursor: pointer; background: #22c55e; color: white; }
    button[disabled] { opacity: .6; cursor: not-allowed; }
    video, canvas { width: 100%; border-radius: 12px; background: #000; min-height: 220px; }
    .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; }
    .log { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace; font-size: .9rem; white-space: pre-wrap; background: rgba(0,0,0,.06); border-radius: 8px; padding: .75rem; max-height: 260px; overflow: auto; }
    .note { opacity: .85; }
  </style>
</head>
<body>
<div class="wrap">
  <h1>Concatenar vídeos + <span style="color:#22c55e">Chroma Key</span> (fondo por vídeo)</h1>

  <div class="card">
    <div class="row">
      <label>Clips (croma verde):
        <input id="fgFiles" type="file" accept="video/*" multiple>
      </label>
      <label>Fondos (vídeo/imagen):
        <input id="bgFiles" type="file" accept="video/*,image/*" multiple>
      </label>
      <label>FPS:
        <input id="fps" type="number" min="5" max="60" step="1" value="24">
      </label>
      <label>Ancho máx.:
        <input id="maxw" type="number" min="320" max="3840" step="16" value="1920">
      </label>
    </div>
    <div class="row" style="margin-top:.5rem;">
      <label>Clave verde (tolerancia):
        <input id="tol" type="range" min="0" max="1" step="0.01" value="0.35">
        <span id="tolVal" class="note">0.35</span>
      </label>
      <label>Suavizado bordes:
        <input id="soft" type="range" min="0" max="1" step="0.01" value="0.10">
        <span id="softVal" class="note">0.10</span>
      </label>
      <label>Ganar calidad:
        <input id="bppf" type="number" min="0.05" max="0.5" step="0.01" value="0.20">
        <span class="note">bits/pixel/frame</span>
      </label>
      <button id="start" disabled>Render MP4 con fondo</button>
      <span id="status" class="note">Selecciona clips y fondos.</span>
    </div>
  </div>

  <div class="grid" style="margin-top:1rem;">
    <div>
      <h3>Preview entrada</h3>
      <video id="preview" controls muted playsinline></video>
    </div>
    <div>
      <h3>Resultado</h3>
      <video id="outVid" controls loop></video>
      <div class="row" style="margin-top:.5rem;">
        <a id="download" style="display:none; text-decoration:none;"><button>Descargar MP4</button></a>
        <span id="meta" class="note"></span>
      </div>
    </div>
  </div>

  <h3 style="margin-top:1rem;">Registro</h3>
  <div class="log" id="log"></div>
</div>

<script type="module">
/* ===== util ===== */
const $ = s => document.querySelector(s);
const logEl = $('#log'), statusEl = $('#status');
const preview = $('#preview'), outVid = $('#outVid'), aDownload = $('#download');
const fpsEl = $('#fps'), maxwEl = $('#maxw'), startBtn = $('#start');
const tolEl = $('#tol'), softEl = $('#soft'), tolVal = $('#tolVal'), softVal = $('#softVal'), bppfEl = $('#bppf');
const log = (t) => { logEl.textContent += t + "\\n"; logEl.scrollTop = logEl.scrollHeight; };

if (location.protocol === 'file:') log('⚠️ Abriendo con file://. Usa servidor local (http(s)://localhost).');

let fgBlobs = [], bgBlobs = [];

$('#fgFiles').addEventListener('change', e => {
  fgBlobs = [...e.target.files];
  startBtn.disabled = !(fgBlobs.length && bgBlobs.length);
  if (fgBlobs[0]) { preview.src = URL.createObjectURL(fgBlobs[0]); preview.load(); }
});
$('#bgFiles').addEventListener('change', e => {
  bgBlobs = [...e.target.files];
  startBtn.disabled = !(fgBlobs.length && bgBlobs.length);
});

tolEl.addEventListener('input', ()=> tolVal.textContent = (+tolEl.value).toFixed(2));
softEl.addEventListener('input', ()=> softVal.textContent = (+softEl.value).toFixed(2));

/* ===== mp4-muxer ===== */
async function loadMuxer() {
  const mod = await import('./vendor/mp4-muxer.mjs');
  const ArrayBufferTarget = mod.ArrayBufferTarget || mod.targets?.ArrayBufferTarget || mod.default?.ArrayBufferTarget;
  function makeMuxer(opts) {
    if (typeof mod.Muxer === 'function') return new mod.Muxer(opts);
    if (typeof mod.MP4Muxer === 'function') return new mod.MP4Muxer(opts);
    if (typeof mod.default === 'function') return new mod.default(opts);
    if (typeof mod.default?.MP4Muxer === 'function') return new mod.default.MP4Muxer(opts);
    throw new Error('No se encontró constructor compatible en mp4-muxer.mjs');
  }
  return { ArrayBufferTarget, makeMuxer };
}
const { ArrayBufferTarget, makeMuxer } = await loadMuxer();

/* ===== WebCodecs helpers ===== */
function checkSupport(){
  if (!('VideoEncoder' in window) || !('VideoFrame' in window)) {
    throw new Error('WebCodecs no disponible en este navegador.');
  }
}
async function pickH264Config({width, height, fps}) {
  const profiles = ['avc1.640032','avc1.64001F','avc1.4D401F','avc1.42E01E'];
  for (const format of ['avc','annexb']) {
    for (const codec of profiles) {
      const s = await VideoEncoder.isConfigSupported({
        codec, width, height, framerate: fps,
        hardwareAcceleration: 'prefer-hardware',
        avc: { format }
      }).catch(()=>null);
      if (s?.supported) return s.config;
    }
  }
  throw new Error('H.264 no soportado por WebCodecs en este dispositivo.');
}
function buildMuxer({width,height,frameRate,decoderConfig,avcFormat='avc',fragmented=false}) {
  const target = new ArrayBufferTarget();
  const muxer = makeMuxer({
    target,
    fastStart: fragmented ? 'fragmented' : false,
    video: {
      codec: 'avc',
      width, height,
      frameRate,
      decoderConfig,
      avcFormat
    }
  });
  return { muxer, target };
}

/* ===== Chroma Key (CPU) ===== */
/** keyParams: { tol, soft } */
function chromaComposite(outCtx, fgCtx, bgCtx, W, H, keyParams) {
  const fg = fgCtx.getImageData(0,0,W,H);
  const bg = bgCtx.getImageData(0,0,W,H);
  const fd = fg.data, bd = bg.data;

  const tol = +keyParams.tol;   // 0..1
  const soft = +keyParams.soft; // 0..1

  // thresholds en espacio “verde” simple
  const T = Math.max(0, Math.min(1, tol));
  const S = Math.max(0, Math.min(1, soft));
  const lo = T - S*0.5;   // inicio suavizado
  const hi = T + S*0.5;   // fin suavizado

  for (let i=0; i<fd.length; i+=4) {
    const r = fd[i]/255, g = fd[i+1]/255, b = fd[i+2]/255;

    // “verde-idad”: g alto y r/b bajos
    const greenStrength = g - Math.max(r,b);

    // alpha 0 en zona claramente verde, 1 fuera; rampa suave entre lo..hi
    let a;
    if (greenStrength <= lo) a = 1;
    else if (greenStrength >= hi) a = 0;
    else {
      const t = (greenStrength - lo)/(hi-lo); // 0..1
      // ease (suavizado)
      a = 1 - (t*t*(3-2*t));
    }

    const invA = 1 - a;
    fd[i]   = Math.round(fd[i]  *a + bd[i]  *invA);
    fd[i+1] = Math.round(fd[i+1]*a + bd[i+1]*invA);
    fd[i+2] = Math.round(fd[i+2]*a + bd[i+2]*invA);
    fd[i+3] = 255;
  }
  outCtx.putImageData(fg, 0, 0);
}

/* ===== Decodificación determinista por seeking y composición por frame ===== */
async function composeClipsToMP4({ fgFiles, bgFiles, fps, maxW, tol, soft, bppf }) {
  checkSupport();
  statusEl.textContent = 'Procesando… (puede tardar)';
  log('⏳ Procesando… (puede tardar)');

  // Prepara elementos <video>/<img> para fondos (mix permitido)
  const makeMedia = (blob) => {
    if (blob.type.startsWith('image/')) {
      const img = new Image(); img.src = URL.createObjectURL(blob);
      return new Promise(res => { img.onload = ()=>res({type:'img', el:img, duration:Infinity}); });
    } else {
      const v = document.createElement('video');
      v.src = URL.createObjectURL(blob); v.muted = true; v.playsinline = true; v.crossOrigin='anonymous';
      return new Promise((res,rej)=>{ v.onloadedmetadata=()=>res({type:'video', el:v, duration:v.duration||0}); v.onerror=()=>rej(new Error('No se pudo cargar fondo.')); });
    }
  };
  const bgMedias = await Promise.all(bgFiles.map(makeMedia));

  // Primer clip para fijar geometría
  const probeVid = document.createElement('video');
  probeVid.src = URL.createObjectURL(fgFiles[0]); probeVid.muted = true; probeVid.playsinline = true;
  await new Promise((res,rej)=>{ probeVid.onloadedmetadata=res; probeVid.onerror=()=>rej(new Error('No se pudo leer clip.')); });

  const scale = Math.min(1, maxW / probeVid.videoWidth);
  let W = Math.round(probeVid.videoWidth * scale) & ~1; // par
  let H = Math.round(probeVid.videoHeight * scale) & ~1;

  // Lienzos
  const fgCanvas = document.createElement('canvas'); fgCanvas.width=W; fgCanvas.height=H;
  const bgCanvas = document.createElement('canvas'); bgCanvas.width=W; bgCanvas.height=H;
  const outCanvas = document.createElement('canvas'); outCanvas.width=W; outCanvas.height=H;
  const fgCtx = fgCanvas.getContext('2d', {alpha:false});
  const bgCtx = bgCanvas.getContext('2d', {alpha:false});
  const outCtx = outCanvas.getContext('2d', {alpha:false});

  // Encoder
  const fpsInt = Math.max(1, Math.round(fps));
  const chosen = await pickH264Config({ width: W, height: H, fps: fpsInt });
  const frameDurUS = Math.round(1_000_000 / fpsInt);
  const targetBitrate = Math.max(1_500_000, Math.round(W*H*fpsInt*bppf));

  const encoderConfig = {
    ...chosen, width:W, height:H, framerate:fpsInt,
    bitrate: targetBitrate, bitrateMode:'variable',
    hardwareAcceleration:'prefer-hardware',
    latencyMode:'quality',
    avc:{ format:'avc' }
  };

  let globalDecoderConfig = null;
  const chunks = [];
  const encoder = new VideoEncoder({
    output: (chunk, metadata) => {
      if (!globalDecoderConfig && metadata?.decoderConfig?.description) {
        globalDecoderConfig = {
          description: metadata.decoderConfig.description,
          colorSpace: { primaries:'bt709', transfer:'bt709', matrix:'bt709', fullRange:false }
        };
      }
      chunks.push({chunk});
    },
    error: e => log('Encoder error: ' + e)
  });
  encoder.configure(encoderConfig);

  // Helpers
  const seekTo = (video, t) => new Promise(res => { video.addEventListener('seeked', res, {once:true}); video.currentTime = t; });
  const drawMedia = async (media, t) => {
    if (media.type === 'img') {
      bgCtx.drawImage(media.el, 0,0,W,H);
    } else {
      const tt = Math.min(t, Math.max(0, media.duration - 1e-3));
      await seekTo(media.el, tt);
      bgCtx.drawImage(media.el, 0,0,W,H);
    }
  };

  // Procesa cada clip con un fondo (ciclado)
  let pts = 0;
  for (let idx=0; idx<fgFiles.length; idx++) {
    const fgBlob = fgFiles[idx];
    const bgMedia = bgMedias[idx % bgMedias.length];

    const v = document.createElement('video');
    v.src = URL.createObjectURL(fgBlob); v.muted = true; v.playsinline = true; v.crossOrigin='anonymous';
    await new Promise((res,rej)=>{ v.onloadedmetadata=res; v.onerror=()=>rej(new Error('No se pudo cargar clip.')); });

    const duration = v.duration || 0;
    const step = 1 / fpsInt;
    const endT = Math.max(0, duration - 1e-3);

    log(`🎬 Clip ${idx+1}/${fgFiles.length} · ${W}×${H} · dur ${(duration).toFixed(2)}s`);

    for (let t=0; t<=duration+1e-9; t+=step) {
      const tt = Math.min(t, endT);
      // draw FG
      await seekTo(v, tt);
      fgCtx.drawImage(v, 0,0,W,H);

      // draw BG (si es video, buscamos al mismo t; si no, se usa imagen)
      await drawMedia(bgMedia, tt);

      // composite
      chromaComposite(outCtx, fgCtx, bgCtx, W, H, { tol, soft });

      // encode
      const frame = new VideoFrame(outCanvas, { timestamp: pts });
      encoder.encode(frame, { keyFrame: (t === 0) });
      frame.close();
      pts += frameDurUS;
    }
  }

  await encoder.flush(); encoder.close();

  log(`🧱 Chunks: ${chunks.length}`);
  const { muxer, target } = buildMuxer({
    width: W, height: H, frameRate: fpsInt,
    decoderConfig: globalDecoderConfig, avcFormat: 'avc', fragmented: false
  });

  let sentCfg = false;
  for (const {chunk} of chunks) {
    const opts = { duration: frameDurUS };
    if (!sentCfg && globalDecoderConfig) { opts.decoderConfig = globalDecoderConfig; sentCfg = true; }
    muxer.addVideoChunk(chunk, opts);
  }
  muxer.finalize();

  const outU8 = new Uint8Array(target.buffer);
  if (!outU8.length) throw new Error('Mux vacío');
  const blob = new Blob([outU8], { type:'video/mp4' });
  return { blob, W, H, fps: fpsInt };
}

/* ===== UI run ===== */
startBtn.addEventListener('click', async () => {
  const fps = Math.max(5, Math.min(60, parseInt(fpsEl.value||'24',10)));
  const maxW = Math.max(320, Math.min(3840, parseInt(maxwEl.value||'1920',10)));
  const tol = +tolEl.value; const soft = +softEl.value; const bppf = +bppfEl.value;

  if (!fgBlobs.length || !bgBlobs.length) return alert('Sube clips (croma) y al menos un fondo.');

  try {
    startBtn.disabled = true;
    const { blob, W, H, fps: fpsOut } = await composeClipsToMP4({
      fgFiles: fgBlobs, bgFiles: bgBlobs, fps, maxW, tol, soft, bppf
    });
    const url = URL.createObjectURL(blob);
    outVid.src = url; outVid.load(); outVid.play().catch(()=>{});
    aDownload.href = url; aDownload.download = `chroma_concat_${W}x${H}_${fpsOut}fps.mp4`;
    aDownload.style.display = 'inline-block';
    $('#meta').textContent = `${(blob.size/1024/1024).toFixed(2)} MB · ${fpsOut} fps · ${W}×${H}`;
    statusEl.textContent = 'Listo ✅';
  } catch (e) {
    console.error(e); log('❌ ' + (e?.message||String(e))); statusEl.textContent = 'Error';
  } finally {
    startBtn.disabled = false;
  }
});
</script>
</body>
</html>
