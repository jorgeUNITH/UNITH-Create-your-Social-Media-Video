<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Compositor Croma Multi-clips → MP4 (WebCodecs)</title>
  <style>
    :root { color-scheme: light dark; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial; margin: 0; padding: 18px; }
    .wrap { max-width: 1100px; margin: 0 auto; }
    h1 { font-size: 1.4rem; margin: 0 0 .5rem; }
    .card { background: rgba(127,127,127,0.08); border: 1px solid rgba(127,127,127,0.2); border-radius: 14px; padding: 1rem; }
    .grid { display: grid; gap: 1rem; grid-template-columns: 1fr; }
    @media (min-width: 1000px) { .grid { grid-template-columns: 1fr 1fr; } }
    .row { display: flex; gap: .75rem; align-items: center; flex-wrap: wrap; }
    .col { display: grid; grid-template-columns: 1fr; gap: .5rem; }
    label { display: inline-flex; align-items: center; gap: .5rem; }
    input[type="file"], input[type="number"], input[type="color"] { padding: .45rem .6rem; border: 1px solid rgba(127,127,127,0.35); border-radius: 10px; }
    input[type="range"] { width: 220px; }
    button { appearance: none; border: 0; padding: .7rem 1rem; border-radius: 12px; font-weight: 600; cursor: pointer; background: #22c55e; color: white; }
    button.secondary { background:#3b82f6; }
    button[disabled] { opacity: .6; cursor: not-allowed; }
    video, canvas { width: 100%; border-radius: 12px; background: #000; min-height: 220px; }
    .note { font-size: .92rem; opacity: .85; }
    .log { font-family: ui-monospace, SFMono, Menlo, Consolas, "Courier New", monospace; font-size: .9rem; white-space: pre-wrap; background: rgba(0,0,0,.06); border-radius: 8px; padding: .75rem; max-height: 240px; overflow: auto; }
    .bar { height: 10px; width: 100%; background: rgba(0,0,0,.08); border-radius: 999px; overflow: hidden; border: 1px solid rgba(127,127,127,0.3); }
    .bar > i { display:block; height:100%; width:0%; background: linear-gradient(90deg, #22c55e, #3b82f6); }
    .kv { display:flex; align-items:center; gap:.6rem; flex-wrap:wrap; }
    .kv > div { display:flex; align-items:center; gap:.35rem; }
    .pill { background: rgba(0,0,0,.06); border: 1px solid rgba(127,127,127,.25); padding:.25rem .5rem; border-radius: 999px; font-size:.85rem; }
  </style>
</head>
<body>
<div class="wrap">
  <h1>Compositor Croma Multi-clips → <span style="color:#22c55e">MP4</span> (WebCodecs)</h1>
  <p class="note">Sube varios vídeos con croma (persona) y varios fondos (vídeo o imagen). Ajusta claves y previsualiza 1 frame. Luego exporta a MP4 (sin audio).</p>

  <div class="grid">
    <div class="card">
      <h3>Entrada</h3>
      <div class="col">
        <label>Clips con croma (FG):
          <input id="fgFiles" type="file" accept="video/*" multiple />
        </label>
        <label>Fondos (BG, vídeo o imagen):
          <input id="bgFiles" type="file" accept="video/*,image/*" multiple />
        </label>
      </div>

      <h4>Ajustes de clave</h4>
      <div class="col">
        <div class="kv">
          <div><span class="pill">Color</span><input id="keyColor" type="color" value="#00ff00"></div>
          <div><span class="pill">Umbral</span>
            <input id="thresh" type="range" min="1" max="255" step="1" value="60">
            <input id="threshNum" type="number" min="1" max="255" step="1" value="60" style="width:70px">
          </div>
          <div><span class="pill">Suavizado</span>
            <input id="smooth" type="range" min="0" max="255" step="1" value="40">
            <input id="smoothNum" type="number" min="0" max="255" step="1" value="40" style="width:70px">
          </div>
          <div><span class="pill">Spill</span>
            <input id="spill" type="range" min="0" max="100" step="1" value="35">
            <input id="spillNum" type="number" min="0" max="100" step="1" value="35" style="width:70px">
          </div>
        </div>

        <div class="row">
          <label>FPS: <input id="fps" type="number" min="5" max="60" step="1" value="24"></label>
          <label>Ancho máx.: <input id="maxw" type="number" min="320" max="4096" step="16" value="1920"></label>
          <button id="previewBtn" class="secondary">Previsualizar (1 frame)</button>
          <button id="start">Componer & Exportar MP4</button>
        </div>

        <div class="row" style="width:100%; align-items:flex-start;">
          <div class="bar"><i id="barFill"></i></div>
          <span id="barText" class="note" style="min-width:180px; text-align:right;">Listo</span>
        </div>

        <div class="row"><span id="status" class="note">Selecciona archivos.</span></div>
      </div>
    </div>

    <div class="card">
      <h3>Previsualización / Resultado</h3>
      <canvas id="previewCanvas"></canvas>
      <video id="outVid" controls loop style="margin-top:.5rem;"></video>
      <div class="row" style="margin-top:.5rem;">
        <a id="download" download="composite.mp4" style="display:none; text-decoration:none;"><button>Descargar MP4</button></a>
        <span id="meta" class="note"></span>
      </div>
    </div>
  </div>

  <h3 style="margin-top:1rem;">Registro</h3>
  <div class="log" id="log"></div>
</div>

<script type="module">
/* ===== Utilidades / UI ===== */
const $ = s => document.querySelector(s);
const logEl = $('#log');
const statusEl = $('#status');
const outVid = $('#outVid');
const aDownload = $('#download');
const fpsEl = $('#fps');
const maxwEl = $('#maxw');
const fgFilesEl = $('#fgFiles');
const bgFilesEl = $('#bgFiles');

const keyColorEl = $('#keyColor');
const threshEl = $('#thresh'); const threshNum = $('#threshNum');
const smoothEl = $('#smooth'); const smoothNum = $('#smoothNum');
const spillEl  = $('#spill');  const spillNum  = $('#spillNum');

const previewBtn = $('#previewBtn');
const startBtn = $('#start');
const previewCanvas = $('#previewCanvas');
const pctx = previewCanvas.getContext('2d', {alpha:false});

const barFill = $('#barFill');
const barText = $('#barText');

const log = (t) => { logEl.textContent += t + "\n"; logEl.scrollTop = logEl.scrollHeight; };
const setProgress = (pct, text) => {
  barFill.style.width = Math.max(0, Math.min(100, pct)) + '%';
  if (text) barText.textContent = text;
};

function linkRangeNumber(range, num){
  const sync = val => { range.value = val; num.value = val; };
  range.addEventListener('input', () => sync(range.value));
  num.addEventListener('input',   () => sync(num.value));
}
linkRangeNumber(threshEl, threshNum);
linkRangeNumber(smoothEl, smoothNum);
linkRangeNumber(spillEl, spillNum);

function hexToRgb(hex) {
  const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex.trim());
  return m ? { r: parseInt(m[1], 16), g: parseInt(m[2], 16), b: parseInt(m[3], 16) } : { r:0,g:255,b:0 };
}

/* ===== Carga mp4-muxer ===== */
async function loadMuxerLocal() {
  const mod = await import('./vendor/mp4-muxer.mjs');
  const ArrayBufferTarget =
    mod.ArrayBufferTarget ||
    mod.targets?.ArrayBufferTarget ||
    mod.default?.ArrayBufferTarget;

  function makeMuxer(opts) {
    if (typeof mod.MP4Muxer === 'function') return new mod.MP4Muxer(opts);
    if (typeof mod.default === 'function') return new mod.default(opts);
    if (typeof mod.default?.MP4Muxer === 'function') return new mod.default.MP4Muxer(opts);
    if (typeof mod.MP4Muxer?.MP4Muxer === 'function') return new mod.MP4Muxer.MP4Muxer(opts);
    if (typeof mod.create === 'function') return mod.create(opts);
    if (typeof mod.Muxer === 'function') return new mod.Muxer(opts);
    throw new Error('No se encontró constructor/fábrica compatible en vendor/mp4-muxer.mjs');
  }
  return { makeMuxer, ArrayBufferTarget };
}
const { makeMuxer, ArrayBufferTarget } = await loadMuxerLocal();

/* ===== WebCodecs helpers ===== */
function checkSupport(){
  if (!('VideoEncoder' in window) || !('VideoFrame' in window)) {
    throw new Error('WebCodecs no disponible en este navegador.');
  }
}
async function pickH264Config({ width, height, fps }) {
  const avc1s = [
    'avc1.640032', // High@L5.0
    'avc1.64001F', // High@L3.1
    'avc1.4D401F', // Main@L3.1
    'avc1.42E01E'  // Baseline@L3.0
  ];
  for (const format of ['avc', 'annexb']) {
    for (const codec of avc1s) {
      const support = await VideoEncoder.isConfigSupported({
        codec, width, height, framerate: fps,
        hardwareAcceleration: 'prefer-hardware',
        avc: { format }
      }).catch(()=>null);
      if (support?.supported) return support.config;
    }
  }
  throw new Error('H.264 no soportado por WebCodecs en este dispositivo.');
}

/* ===== Media helpers ===== */
function isVideo(media) { return media instanceof HTMLVideoElement; }
function getDurationSec(media) {
  return isVideo(media) ? (media.duration || 0) : 0;
}
function loadMedia(file){
  return new Promise((resolve,reject) => {
    const type = file.type || '';
    if (type.startsWith('image/')) {
      const img = new Image();
      img.onload = () => resolve(img);
      img.onerror = () => reject(new Error('No se pudo cargar imagen.'));
      img.src = URL.createObjectURL(file);
    } else {
      const v = document.createElement('video');
      v.muted = true; v.playsinline = true; v.crossOrigin = 'anonymous';
      v.onloadedmetadata = () => resolve(v);
      v.onerror = () => reject(new Error('No se pudo cargar vídeo.'));
      v.src = URL.createObjectURL(file);
    }
  });
}
function seekMedia(media, t){
  return new Promise(res => {
    if (!isVideo(media)) return res(); // imágenes no requieren seek
    const on = () => res();
    media.addEventListener('seeked', on, { once:true });
    media.currentTime = Math.max(0, Math.min(t, (media.duration || 0) - 0.0005));
  });
}
function drawMediaOnCtx(ctx, media, W, H){
  if (isVideo(media)) {
    ctx.drawImage(media, 0, 0, W, H);
  } else {
    // imagen: aspect-fit con letterbox
    const iw = media.naturalWidth, ih = media.naturalHeight;
    const s = Math.min(W/iw, H/ih);
    const w = Math.round(iw*s), h = Math.round(ih*s);
    const x = Math.floor((W-w)/2), y = Math.floor((H-h)/2);
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    ctx.drawImage(media, x, y, w, h);
  }
}

/* ===== Croma compositing en CPU (rápido) ===== */
function chromaComposite(fgCtx, bgCtx, outCtx, W, H, { keyRGB, threshold, smooth, spill }) {
  const fgd = fgCtx.getImageData(0,0,W,H);
  const bgd = bgCtx.getImageData(0,0,W,H);
  const fd = fgd.data, bd = bgd.data;

  const kr = keyRGB.r, kg = keyRGB.g, kb = keyRGB.b;
  const T  = Math.max(1, threshold|0);
  const S  = Math.max(0, smooth|0);
  const SP = Math.max(0, spill|0) / 100; // 0..1

  for (let i=0; i<fd.length; i+=4) {
    const r = fd[i], g = fd[i+1], b = fd[i+2];

    // dist euclídea al color clave
    const dr = r-kr, dg = g-kg, db = b-kb;
    const dist = Math.sqrt(dr*dr + dg*dg + db*db);

    // alpha duro + borde suave (feather) en [T-S, T+S]
    let alpha;
    if (dist <= T-S) alpha = 0;
    else if (dist >= T+S) alpha = 1;
    else alpha = (dist-(T-S)) / (2*S);

    // spill: reduce dominante verde sobre zonas mixtas
    let rr = r, gg = g, bb = b;
    if (SP > 0) {
      const avg = (r+b)*0.5;
      if (g > avg) {
        const spillAmt = (g-avg) * SP;
        gg = Math.max(0, g - spillAmt);
      }
    }

    const inv = 1 - alpha;
    fd[i  ] = (rr * alpha + bd[i  ] * inv) | 0;
    fd[i+1] = (gg * alpha + bd[i+1] * inv) | 0;
    fd[i+2] = (bb * alpha + bd[i+2] * inv) | 0;
    fd[i+3] = 255;
  }
  outCtx.putImageData(fgd, 0, 0);
}

/* ===== PREVIEW (1 frame) ===== */
previewBtn.addEventListener('click', async () => {
  try {
    if (!(fgFilesEl.files?.length && bgFilesEl.files?.length)) {
      alert('Selecciona al menos 1 clip con croma y 1 fondo.');
      return;
    }
    previewBtn.disabled = true;
    setProgress(0, 'Previsualizando…');
    log('👀 Generando previsualización (1 frame)…');

    const fpsInt = Math.max(1, Math.round(parseInt(fpsEl.value||'24',10)));
    const maxW   = Math.max(320, Math.min(4096, parseInt(maxwEl.value||'1920',10)));
    const keyRGB = hexToRgb(keyColorEl.value);
    const threshold = +threshEl.value;
    const smooth    = +smoothEl.value;
    const spill     = +spillEl.value;

    // 1er par
    const fgFile = fgFilesEl.files[0];
    const bgFile = bgFilesEl.files[0];
    const fgMedia = await loadMedia(fgFile);
    const bgMedia = await loadMedia(bgFile);

    const Wsrc = fgMedia.videoWidth || fgMedia.naturalWidth || 1280;
    const Hsrc = fgMedia.videoHeight || fgMedia.naturalHeight || 720;
    const scale = Math.min(1, maxW / Wsrc);
    let W = Math.round(Wsrc * scale), H = Math.round(Hsrc * scale);
    if (W%2) W--; if (H%2) H--;

    previewCanvas.width = W; previewCanvas.height = H;
    const fgCanvas = document.createElement('canvas'); fgCanvas.width=W; fgCanvas.height=H;
    const bgCanvas = document.createElement('canvas'); bgCanvas.width=W; bgCanvas.height=H;
    const fgCtx = fgCanvas.getContext('2d', {alpha:false});
    const bgCtx = bgCanvas.getContext('2d', {alpha:false});

    const duration = getDurationSec(fgMedia) || 1;
    const t = Math.min(Math.max(0, duration*0.5), Math.max(0, duration-0.001));
    if (isVideo(fgMedia)) await seekMedia(fgMedia, t);
    if (isVideo(bgMedia)) {
      const d = getDurationSec(bgMedia) || duration;
      await seekMedia(bgMedia, Math.min(d-0.001, t % d));
    }

    drawMediaOnCtx(fgCtx, fgMedia, W, H);
    drawMediaOnCtx(bgCtx, bgMedia, W, H);

    chromaComposite(fgCtx, bgCtx, pctx, W, H, { keyRGB, threshold, smooth, spill });
    setProgress(15, 'Preview listo');
    log('✅ Previsualización actualizada.');
  } catch (e) {
    console.error(e);
    log('❌ Previsualización: ' + (e?.message || String(e)));
  } finally {
    previewBtn.disabled = false;
  }
});

/* ===== MUXER helper ===== */
function buildMuxer({ width, height, frameRate, decoderConfig, avcFormat='avc', fragmented=false }) {
  const target = ArrayBufferTarget ? new ArrayBufferTarget() : 'buffer';
  const muxer = makeMuxer({
    target,
    fastStart: fragmented ? 'fragmented' : false,
    video: {
      codec: 'avc',
      width,
      height,
      frameRate,
      decoderConfig, // { description, colorSpace }
      avcFormat
    }
  });
  return { muxer, target };
}

/* ===== COMPOSICIÓN Y EXPORT ===== */
startBtn.addEventListener('click', async () => {
  try {
    await composeClipsToMP4();
  } catch (e) {
    console.error(e);
    statusEl.textContent = 'Error';
    log('❌ ' + (e?.message || String(e)));
  }
});

async function composeClipsToMP4(){
  checkSupport();
  if (!(fgFilesEl.files?.length && bgFilesEl.files?.length)) {
    alert('Selecciona al menos 1 clip con croma y 1 fondo.');
    return;
  }
  startBtn.disabled = true; previewBtn.disabled = true;
  setProgress(0, 'Preparando…');
  statusEl.textContent = '⏳ Procesando… (puede tardar)';
  log('⏳ Preparando…');

  const fpsInt = Math.max(1, Math.round(parseInt(fpsEl.value||'24',10)));
  const maxW   = Math.max(320, Math.min(4096, parseInt(maxwEl.value||'1920',10)));
  const keyRGB = hexToRgb(keyColorEl.value);
  const threshold = +threshEl.value;
  const smooth    = +smoothEl.value;
  const spill     = +spillEl.value;

  const fgList = Array.from(fgFilesEl.files);
  const bgList = Array.from(bgFilesEl.files);
  const pairs = fgList.map((fgFile, i) => [fgFile, bgList[i % bgList.length]]);

  // cargamos medios
  const medias = await Promise.all(pairs.flat().map(loadMedia));
  const fgMedias = medias.filter((_,i)=>i%2===0);
  const bgMedias = medias.filter((_,i)=>i%2===1);

  // dimensiones salida según primer fg
  const firstFG = fgMedias[0];
  const Wsrc = firstFG.videoWidth || firstFG.naturalWidth || 1280;
  const Hsrc = firstFG.videoHeight || firstFG.naturalHeight || 720;
  const scale = Math.min(1, maxW / Wsrc);
  let W = Math.round(Wsrc * scale), H = Math.round(Hsrc * scale);
  if (W%2) W--; if (H%2) H--;

  // canvases trabajo
  const fgCanvas = document.createElement('canvas'); fgCanvas.width=W; fgCanvas.height=H;
  const bgCanvas = document.createElement('canvas'); bgCanvas.width=W; bgCanvas.height=H;
  const outCanvas = document.createElement('canvas'); outCanvas.width=W; outCanvas.height=H;
  const fgCtx = fgCanvas.getContext('2d', {alpha:false});
  const bgCtx = bgCanvas.getContext('2d', {alpha:false});
  const outCtx = outCanvas.getContext('2d', {alpha:false});

  // encoder
  const chosen = await pickH264Config({ width: W, height: H, fps: fpsInt });
  const BPPF = 0.22;
  const targetBitrate = Math.max(2_000_000, Math.round(W * H * fpsInt * BPPF));
  const encoderConfig = {
    ...chosen,
    width: W, height: H, framerate: fpsInt,
    bitrate: targetBitrate,
    bitrateMode: 'variable',
    hardwareAcceleration: 'prefer-hardware',
    latencyMode: 'quality',
    contentHint: 'detail',
    avc: { format: 'avc' }
  };
  const chunks = [];
  let globalDecoderConfig = null;

  const encoder = new VideoEncoder({
    output: (chunk, metadata) => {
      if (!globalDecoderConfig && metadata?.decoderConfig?.description) {
        globalDecoderConfig = {
          description: metadata.decoderConfig.description,
          colorSpace: { primaries:'bt709', transfer:'bt709', matrix:'bt709', fullRange:false }
        };
      }
      chunks.push({ chunk });
    },
    error: (e) => log('Encoder error: ' + e)
  });
  encoder.configure(encoderConfig);

  const frameDurUS = Math.round(1_000_000 / fpsInt);
  let pts = 0;
  let totalFrames = 0;
  const pairDurations = [];

  // pre-calcula #frames total para progreso
  for (let i=0;i<pairs.length;i++){
    const fg = fgMedias[i];
    const d  = getDurationSec(fg) || 0;
    const frames = Math.max(0, Math.round(d*fpsInt));
    pairDurations.push({d, frames});
    totalFrames += frames;
  }
  const totalFramesPingPong = totalFrames * 2 - pairs.length*2; // cada clip se duplica sin extremos

  let framesDone = 0;
  const step = 1 / fpsInt;

  // procesa cada par
  for (let i=0;i<pairs.length;i++){
    const fg = fgMedias[i];
    const bg = bgMedias[i];

    const d = pairDurations[i].d || 0;
    if (d <= 0) continue;

    // forward
    for (let t=0; t<=d-1e-6; t+=step) {
      if (isVideo(fg)) await seekMedia(fg, t);
      if (isVideo(bg)) {
        const DBG = getDurationSec(bg) || d;
        await seekMedia(bg, Math.min(DBG-0.001, t % DBG));
      }
      drawMediaOnCtx(fgCtx, fg, W, H);
      drawMediaOnCtx(bgCtx, bg, W, H);
      chromaComposite(fgCtx, bgCtx, outCtx, W, H, { keyRGB, threshold, smooth, spill });

      const frame = new VideoFrame(outCanvas, { timestamp: pts });
      encoder.encode(frame, { keyFrame: (pts===0) });
      frame.close();
      pts += frameDurUS;

      framesDone++;
      if (framesDone % 10 === 0) {
        const pct = (framesDone / totalFramesPingPong) * 100;
        setProgress(pct, `Codificando… ${framesDone}/${totalFramesPingPong}`);
      }
    }

    // reverse (omite extremos)
    const dFrames = Math.max(0, Math.round(d*fpsInt));
    for (let k=dFrames-2; k>=1; k--) {
      const t = k * step;
      if (isVideo(fg)) await seekMedia(fg, t);
      if (isVideo(bg)) {
        const DBG = getDurationSec(bg) || d;
        await seekMedia(bg, Math.min(DBG-0.001, t % DBG));
      }
      drawMediaOnCtx(fgCtx, fg, W, H);
      drawMediaOnCtx(bgCtx, bg, W, H);
      chromaComposite(fgCtx, bgCtx, outCtx, W, H, { keyRGB, threshold, smooth, spill });

      const frame = new VideoFrame(outCanvas, { timestamp: pts });
      encoder.encode(frame);
      frame.close();
      pts += frameDurUS;

      framesDone++;
      if (framesDone % 10 === 0) {
        const pct = (framesDone / totalFramesPingPong) * 100;
        setProgress(pct, `Codificando… ${framesDone}/${totalFramesPingPong}`);
      }
    }
  }

  await encoder.flush();
  encoder.close();

  setProgress(96, 'Muxeando MP4…');

  // mux
  const { muxer, target } = buildMuxer({
    width: W, height: H, frameRate: fpsInt,
    decoderConfig: globalDecoderConfig,
    avcFormat: 'avc', fragmented: false
  });

  let sentConfig = false;
  for (const { chunk } of chunks) {
    const opts = { duration: frameDurUS };
    if (!sentConfig && globalDecoderConfig) { opts.decoderConfig = globalDecoderConfig; sentConfig = true; }
    muxer.addVideoChunk(chunk, opts);
  }
  muxer.finalize();
  const outU8 = target?.buffer instanceof ArrayBuffer ? new Uint8Array(target.buffer) : new Uint8Array(0);
  if (!outU8.length) throw new Error('Muxer produjo salida vacía.');

  const blob = new Blob([outU8], { type: 'video/mp4' });
  const url = URL.createObjectURL(blob);
  outVid.src = url; outVid.load(); outVid.play().catch(()=>{});
  aDownload.href = url; aDownload.style.display = 'inline-block';
  aDownload.download = `composite_${fpsInt}fps_${W}x${H}.mp4`;
  $('#meta').textContent = `${(blob.size/1024/1024).toFixed(2)} MB · ${fpsInt} fps · ${W}×${H}`;

  statusEl.textContent = '✅ Listo';
  setProgress(100, 'Completado');
  log('✅ Export finalizado.');
  startBtn.disabled = false; previewBtn.disabled = false;
}
</script>
</body>
</html>
